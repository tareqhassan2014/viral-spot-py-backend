# GET `/api/viral-analysis/{queue_id}/results` âš¡

Retrieves the final results of a viral analysis job.

## Description

This is the endpoint to call to retrieve the final, comprehensive results of a viral ideas analysis job. Once a job's status is `completed`, this endpoint will return a rich dataset containing all the insights generated by the AI pipeline.

The response includes:

-   Detailed information about the analysis process itself.
-   The primary user's profile data.
-   A list of the competitor profiles that were analyzed.
-   The reels from both the primary user and competitors that were used in the analysis.
-   The core `analysis_data` object, which contains the main insights, such as generated hooks, profile analysis, and more.

## Path Parameters

| Parameter  | Type   | Description                                       |
| :--------- | :----- | :------------------------------------------------ |
| `queue_id` | string | The ID of the completed analysis job to retrieve. |

## Execution Flow

1.  **Receive Request**: The endpoint receives a GET request with a `queue_id` in the URL path.
2.  **Verify Job Completion**: It first queries the `viral_ideas_queue` table to ensure that the job with the given `queue_id` has a status of `completed`. If not, it returns a `404 Not Found` error.
3.  **Fetch Analysis Results**: It then queries multiple tables to assemble the final response:
    -   `viral_analysis_results`: To get the main analysis data.
    -   `primary_profiles`: To get the data for the primary user.
    -   `viral_ideas_competitors`: To get the list of competitor usernames.
    -   `viral_analysis_reels`: To get the list of reels that were part of the analysis.
4.  **Combine and Transform**: The data from these various tables is combined and transformed into a single, comprehensive JSON object.
5.  **Send Response**: The final JSON object is returned with a `200 OK` status.

## Detailed Implementation Guide

### Python (FastAPI)

```python
# In backend_api.py

@app.get("/api/viral-analysis/{queue_id}/results")
async def get_viral_analysis_results(queue_id: str, ...):
    """Get viral analysis results for a queue entry"""
    try:
        # 1. Get primary username from the queue table
        queue_result = api_instance.supabase.client.table('viral_ideas_queue').select('primary_username').eq('id', queue_id).execute()

        # 2. Get the analysis results from `viral_analysis_results` table
        analysis_result = api_instance.supabase.client.table('viral_analysis_results').select(...).eq('queue_id', queue_id).order('analysis_run', desc=True).limit(1).execute()

        # 3. Get the reels used in the analysis from `viral_analysis_reels` table
        reels_result = api_instance.supabase.client.table('viral_analysis_reels').select(...).eq('analysis_id', analysis_id).execute()

        # 4. Get competitor and primary profile data
        # ... more queries ...

        # 5. Combine all data into a single large response object and return
        return APIResponse(success=True, data={...})

    except Exception as e:
        # ... error handling ...
```

**Line-by-Line Explanation:**

This endpoint is a data aggregation endpoint. It performs multiple queries to different tables (`viral_ideas_queue`, `viral_analysis_results`, `viral_analysis_reels`, `primary_profiles`, etc.) to gather all the information related to a completed analysis. It then combines all of this data into a single, large JSON response for the frontend to display.

### Nest.js (Mongoose)

```typescript
// In your viral-ideas.controller.ts

@Get('/analysis/:queueId/results')
async getAnalysisResults(@Param('queueId') queueId: string) {
  const result = await this.viralIdeasService.getAnalysisResults(queueId);
  // ... handle not found ...
  return { success: true, data: result };
}

// In your viral-ideas.service.ts

async getAnalysisResults(queueId: string): Promise<any> {
  // Use .populate() to chain related data together.
  // This assumes you have set up `ref` properties correctly in your Mongoose schemas.
  const results = await this.viralAnalysisResultModel
    .findOne({ queue_id: queueId })
    .sort({ analysis_run: -1 })
    .populate({
      path: 'queue_id',
      populate: [
        { path: 'primary_profile_id' },
        { path: 'competitors' } // Assuming a virtual populate
      ]
    })
    .populate('reels') // Assuming `reels` is an array of refs
    .exec();

  if (!results) {
    return null;
  }

  // Transform the heavily populated `results` object into the desired frontend structure.
  return this.transformResultsForFrontend(results);
}
```

## Responses

### Success: 200 OK

Returns a large JSON object with the complete analysis results.

**Example Response (Structure):**

```json
{
    "success": true,
    "data": {
        "analysis": {
            "id": "analysis_uuid",
            "status": "completed"
            // ... other analysis metadata
        },
        "primary_profile": {
            "username": "user_profile"
            // ... other profile data
        },
        "competitor_profiles": [
            {
                "username": "competitor1"
                // ... other competitor data
            }
        ],
        "reels": [
            {
                "content_id": "reel_abc",
                "reel_type": "primary"
                // ... other reel data
            }
        ],
        "analysis_data": {
            "profile_analysis": {
                // ... detailed analysis of the primary profile
            },
            "generated_hooks": [
                {
                    "hook_text": "You won't believe this..."
                    // ... other hook data
                }
            ]
            // ... many other analysis sections
        }
    }
}
```

### Error: 404 Not Found

Returned if the `queue_id` is not found, or if the analysis results for that job are not yet available.

### Error: 500 Internal Server Error

Returned for any other server-side errors.

## Implementation Details

-   **File:** `backend_api.py`
-   **Function:** `get_viral_analysis_results(queue_id: str, ...)`
-   **Database Tables:** This endpoint queries multiple tables to assemble the final response, including:
    -   `viral_ideas_queue`
    -   `primary_profiles`
    -   `viral_analysis_results`
    -   `viral_analysis_reels`
    -   `viral_ideas_competitors`
    -   `content`
    -   `viral_scripts`
-   **Core Data:** The most important part of the response is the `analysis_data` JSONB field from the `viral_analysis_results` table, which contains the bulk of the AI-generated insights.
